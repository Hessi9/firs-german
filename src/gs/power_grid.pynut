power_grid <- {}
power_grid.power_station_empty_tiles <- [];

function find_power_sources()
/* find all the industries that generate power */
{
    // !! todo: find more than just power station
    local power_plant_id = GSIndustryType.ResolveNewGRFID(firs.grfid, 0x42);
    GSLog.Info("power_plant_id " + power_plant_id);

    // clear the existing list
    power_grid.power_station_empty_tiles.clear();

    local industry_list = GSIndustryList();
    foreach (industry, _ in industry_list) {
        if (GSIndustry.GetIndustryType(industry) == power_plant_id) {
            GSLog.Info("found " + GSIndustry.GetName(industry) + " at tile " + GSIndustry.GetLocation(industry));
            local pylon_start_location = find_empty_tile_near_industry(industry);
            if (pylon_start_location != null)
            {
                power_grid.power_station_empty_tiles.append(pylon_start_location);
                local pylon_object_id = GSObjectType.ResolveNewGRFID(0x47477015, 0x51);
                GSObjectType.BuildObject(pylon_object_id, 0, pylon_start_location);
            }
        }
    }
    create_lineman_graph();
}

function find_empty_tile_near_industry(industry)
{
	// Create spiral walker
	local SPIRAL_WALKER = SpiralWalker();
	SPIRAL_WALKER.Start(GSIndustry.GetLocation(industry));

	// Create try counter
	local TRIES = 0;
	// if no tile found within this distance, don't bother
	local MAX_TRIES = 16 * 16;

	while(TRIES < MAX_TRIES)
	{
		// Inc tries
		TRIES++;

		// Walk one tile
		SPIRAL_WALKER.Walk();
		// Get tile
		local CURRENT_TILE = SPIRAL_WALKER.GetTile();
	    if (GSTile.IsBuildable(CURRENT_TILE) && (TRIES > 38))
	    {
	        return CURRENT_TILE;
	    }
	}
	// no buildable tile found
	return null;
}

function lineman_find_empty_tile_for_pylon(location_tile_index)
{
	// Create spiral walker
	local SPIRAL_WALKER = SpiralWalker();
	SPIRAL_WALKER.Start(location_tile_index);

	// Create try counter
	local TRIES = 0;
	// if no tile found within this distance, don't bother
	local MAX_TRIES = 5 * 5;

	while(TRIES < MAX_TRIES)
	{
		// Inc tries
		TRIES++;

		// Walk one tile
		SPIRAL_WALKER.Walk();
		// Get tile
		local CURRENT_TILE = SPIRAL_WALKER.GetTile();
	    if (GSTile.IsBuildable(CURRENT_TILE))
	    {
	        return CURRENT_TILE;
	    }
	}
	// no buildable tile found
	return null;
}


function lineman_sort_by_distance(a, b)
{
    if (a[0] > b[0]) return 1;
    if (a[0] < b[0]) return -1;
    return 0;
}

function create_lineman_graph()
{
    power_grid.all_nodes <- clone power_grid.power_station_empty_tiles;
    power_grid.unconnected_nodes <- clone power_grid.all_nodes;
    power_grid.links <- [];
    while (power_grid.unconnected_nodes.len() > 0)
    {
        local current_node = power_grid.unconnected_nodes.pop();
        local candidate_nodes_with_edge_distances = [];
        foreach (candidate_dest_node in power_grid.all_nodes)
        {
            if (candidate_dest_node != current_node)
            {
                candidate_nodes_with_edge_distances.append([GSTile.GetDistanceManhattanToTile(current_node, candidate_dest_node), candidate_dest_node]);
            }
        }
        candidate_nodes_with_edge_distances.sort(lineman_sort_by_distance);
        power_grid.links.append([current_node, candidate_nodes_with_edge_distances[0][1]]);
    }
    GSLog.Info("=========");
    foreach (link in power_grid.links)
    {
        GSLog.Info(link[0] + ", " + link[1]);
    }
    GSLog.Info("=========");
}

function lineman_build_pylon(location)
{
    local pylon_object_id = GSObjectType.ResolveNewGRFID(0x47477015, 0x51);
    // GSLog.Info("pylon_object_id " + pylon_object_id);
    GSObjectType.BuildObject(pylon_object_id, 0, location);
}


function pathfinder_test()
{
    if (power_grid.links.len() == 0)
    {
        GSLog.Info("Lineman: Power grid complete, nothing to do");
        return;
    }
    local current_link = power_grid.links.pop();
    local start_node = current_link[0];
    local dest_node = current_link[1];

    /* Print the names of the towns we'll try to connect. */
    GSLog.Info("Going to connect " + start_node + " to " + dest_node);

    GSLog.Info("Manhattan distance " + GSTile.GetDistanceManhattanToTile(start_node, dest_node));
    local num_pylons_to_build = GSTile.GetDistanceManhattanToTile(start_node, dest_node) / 10;
    GSLog.Info("num_pylons_to_build " + num_pylons_to_build);

    local start_x = GSMap.GetTileX(start_node);
    local delta_x = (start_x - GSMap.GetTileX(dest_node)) / num_pylons_to_build;
    local start_y = GSMap.GetTileY(start_node);
    local delta_y = (start_y - GSMap.GetTileY(dest_node)) / num_pylons_to_build;

    local num_pylons_built = 0;
    while (num_pylons_built < num_pylons_to_build)
    {
        num_pylons_built = num_pylons_built + 1;
        local next_loc_x = start_x - (num_pylons_built * delta_x);
        local next_loc_y = start_y - (num_pylons_built * delta_y);
        local next_loc_tile_index = GSMap.GetTileIndex(next_loc_x, next_loc_y)
        GSLog.Info("next_loc_x: " + next_loc_x);
        GSLog.Info("next_loc_y: " + next_loc_y);
        GSLog.Info("tile index for next loc: " + next_loc_tile_index);
        local nearest_buildable_tile_to_next_loc = lineman_find_empty_tile_for_pylon(next_loc_tile_index);
        if (nearest_buildable_tile_to_next_loc != null)
        {
            GSLog.Info("building a pylon...");
            lineman_build_pylon(nearest_buildable_tile_to_next_loc);
        }
    }
}
